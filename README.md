# Cache Architecture: Simulator Design

![Project Status](https://img.shields.io/badge/status-Completed-brightgreen.svg)
![Platform](https://img.shields.io/badge/platform-Software%20Simulation-blue.svg)
![Tool](https://img.shields.io/badge/tool-GCC%20%2F%20G%2B%2B-yellow.svg)
![Language](https://img.shields.io/badge/language-C%20%2F%20C%2B%2B-purple.svg)
![License: MIT](https://img.shields.io/badge/license-MIT-lightgrey.svg)

This repository contains **two key projects** that explore the core principles of cache architecture, both implemented in **C/C++**:

- **Cache Simulator (Lab 09):** A fully functional cache simulator built from scratch in C that models cache behavior using valgrind memory traces.
- **Replacement Policy Analysis (Lab 08):** Implementation and analysis of the **Least Recently Used (LRU)** replacement policy in a C++ cache simulator.

Together, these projects demonstrate how cache mapping, operation, and replacement policies affect performance optimization.

---

## ðŸ§© Project Overview

The **"Memory Wall"** problem highlights how CPU speeds have far outpaced main memory speeds. **Caches** bridge this gap by storing frequently used data in small, fast memory blocks.

This project explores two core design questions:

1. **How do we design a cache?**  
   By building a flexible simulator (`csim.c`) that can model different cache configurations (Set size, Associativity, Block size) and measure performance.

2. **How do we optimize a cache?**  
   By implementing an intelligent **LRU** policy to replace naive eviction strategies, proving its effectiveness through simulation results.

> **[IMAGE PLACEHOLDER]**: Insert a high-level diagram of the CPUâ€“Cacheâ€“Memory hierarchy (e.g., from Slide 2 of your presentation).

---

## âš™ï¸ Core Features

### **1. Configurable Cache Simulator (Lab 09)**
- Developed in **C** from scratch.
- Parses **valgrind**-generated memory traces.
- Supports any `(S, E, B)` configuration (Sets, Associativity, Block size).
- Reports **hit**, **miss**, and **eviction** statistics.
- Enables detailed analysis of cache performance.

### **2. LRU Replacement Policy (Lab 08)**
- Implemented in **C++** within an existing cache simulator.
- Replaces a naive â€œalways evict Way 0â€ policy.
- Uses **timestamp/counter-based tracking** to evict the **Least Recently Used** block.
- Demonstrates significantly reduced miss rates, especially for workloads with **temporal locality**.

---

## ðŸ§  Architecture and Design

### **Part 1: Cache Simulator from Scratch (Lab 09)**

The simulator (`csim.c`) models real cache hardware behavior and processes **memory traces** generated by valgrind. Each line of the trace represents a memory operation (e.g., `L 0x1a2b3c, 4`).

#### **Core Workflow**
1. **Parse Access:** Read each trace instruction.  
2. **Address Calculation:** Extract **tag** and **set index** from the 64-bit address.  
3. **Set Selection:** Locate the correct cache set (2D array of structs).  
4. **Hit Check:** Match tags in valid lines.  
5. **Miss Handling:**  
   - If an empty line exists â†’ fill it.  
   - If all lines are occupied â†’ **evict** using LRU.  
6. **Report:** Output total **hits**, **misses**, and **evictions**.

> **[IMAGE PLACEHOLDER]**: Insert a diagram showing cache address mapping (Tag, Set, Offset).

---

### **Part 2: LRU Policy Implementation (Lab 08)**

The existing simulator (`cachesim.cpp`) was modified to integrate the **LRU policy**.

#### **Before (Naive Policy)**
- The cache always evicted **Way 0**, regardless of usage.
- Inefficient, as frequently accessed blocks could be evicted prematurely.

#### **After (LRU Policy)**
- Each cache line tracks a **timestamp counter**.
- On every access:
  - The accessed line resets its counter to **0** (most recently used).
  - Others increment by **1** (aging).
- On eviction, the line with the **largest counter** (oldest) is replaced.

This effectively applies the **Principle of Temporal Locality**, optimizing cache efficiency.

---

## ðŸ“‚ Module Structure

| Path | Description |
|------|--------------|
| **Lab08_Policy_Exploration/** | Contains files for the LRU policy implementation. |
| â”œâ”€â”€ `cachesim.cpp` | C++ simulator source (LRU logic implemented in `cache_flush`). |
| â”œâ”€â”€ `cachesim.h` | Header file with LRU data structures and declarations. |
| â”œâ”€â”€ `Makefile` | Build script for the simulator. |
| â””â”€â”€ `benchmarks/` | Contains benchmark assembly files (`exa.s`, `sort.s`). |
| **Lab09_Simulator_Design/** | Contains files for the cache simulator from scratch. |
| â”œâ”€â”€ `csim.c` | Main C source for the simulator. |
| â”œâ”€â”€ `cachelab.h` | Header with cache struct definitions and utilities. |
| â”œâ”€â”€ `Makefile` | Build script for the simulator. |
| â””â”€â”€ `traces/` | Contains memory traces (`dave.trace`, `yi.trace`, etc.). |

---

## ðŸ“Š Simulation and Results

### **Testing**
- **`csim.c` (Lab 09):**  
  Validated against a **reference simulator** using provided trace files.
- **`cachesim.cpp` (Lab 08):**  
  Benchmarked using **`exa.s`** and **`sort.s`** under multiple cache configurations (1-way, 2-way, 4-way).

### **Findings**

> **[IMAGE PLACEHOLDER]**: Insert a results bar chart comparing Random vs. LRU miss rates (from Slide 11).

- **Key Finding 1:** LRU drastically reduces miss rates, especially in workloads with high temporal locality (e.g., `sort.s`).  
- **Key Finding 2:** LRU performs best with **higher associativity (4-way)**, as it gains more flexibility in replacement decisions.

---

## ðŸ§° Tools Used

- **Languages:** C, C++
- **Toolchain:** GCC, G++, Make
- **Profiler:** Valgrind (for trace generation)
- **Environment:** Linux / UNIX-based systems

---

# Future Improvements

Implement More Policies: Add and compare LFU, Random, and Pseudo-LRU strategies.

Simulate Write Policies: Include Write-Back vs. Write-Through and Write-Allocate vs. No-Write-Allocate mechanisms.

Multi-Level Caches: Extend csim.c to simulate a multi-level (L1 + L2) cache hierarchy.

# ðŸ“œ License

This project is licensed under the MIT License
.

# ðŸ§¾ Summary

This project serves as a practical exploration of cache architecture in computer systems â€” from designing a simulator to evaluating real-world replacement policies.
It bridges theory with implementation, showcasing how software simulation can be used to analyze and optimize hardware-level performance.
make
./csim -s <s> -E <E> -b <b> -t <tracefile>
