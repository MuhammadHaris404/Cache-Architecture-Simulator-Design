# Cache Architecture: Simulator Design

![Project Status](https://img.shields.io/badge/status-Completed-brightgreen.svg)
![Platform](https://img.shields.io/badge/platform-Software%20Simulation-blue.svg)
![Tool](https://img.shields.io/badge/tool-GCC%20%2F%20G%2B%2B-yellow.svg)
![Language](https://img.shields.io/badge/language-C%20%2F%20C%2B%2B-purple.svg)
![License: MIT](https://img.shields.io/badge/license-MIT-lightgrey.svg)

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/00993684-6935-4b5c-8112-c5c082aa1c73" />

This repository contains **two key projects** that explore the core principles of cache architecture, both implemented in **C/C++**:

- **Cache Simulator:** A fully functional cache simulator built from scratch in C that models cache behavior using valgrind memory traces.
- **Replacement Policy Analysis:** Implementation and analysis of the **Least Recently Used (LRU)** replacement policy in a C++ cache simulator.

Together, this project demonstrate how cache mapping, operation, and replacement policies affect performance optimization.


## Project Overview

The **"Memory Wall"** problem highlights how CPU speeds have far outpaced main memory speeds. **Caches** bridge this gap by storing frequently used data in small, fast memory blocks. This project explores two core design questions:

1. **How do we design a cache?**  
   By building a flexible simulator (`csim.c`) that can model different cache configurations (Set size, Associativity, Block size) and measure performance.

2. **How do we optimize a cache?**  
   By implementing an intelligent **LRU** policy to replace naive eviction strategies, proving its effectiveness through simulation results.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/eafbce50-969c-4fe4-bcc4-349c928771a0" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/1d97da6e-7f72-4790-a41c-04aa4ffeb4cd" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/8abf47ee-0a74-4103-9680-7327d3d93755" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/6afe1b23-bf9e-495f-9121-cecac5711ee1" />

## Core Features

### **1. Configurable Cache Simulator**
- Developed in **C** from scratch.
- Parses **valgrind**-generated memory traces.
- Supports any `(S, E, B)` configuration (Sets, Associativity, Block size).
- Reports **hit**, **miss**, and **eviction** statistics.
- Enables detailed analysis of cache performance.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/a11e0cac-d811-4201-84a2-a11ac34a5404" />

### **2. LRU Replacement Policy**
- Implemented in **C++** within an existing cache simulator.
- Replaces a naive “always evict Way 0” policy.
- Uses **timestamp/counter-based tracking** to evict the **Least Recently Used** block.
- Demonstrates significantly reduced miss rates, especially for workloads with **temporal locality**.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/d644f140-b6be-432e-baea-e566ed0ab72e" />

## Architecture and Design

### **Part 1: Cache Simulator from Scratch**
The simulator (`csim.c`) models real cache hardware behavior and processes **memory traces** generated by valgrind. Each line of the trace represents a memory operation (e.g., `L 0x1a2b3c, 4`).

#### **Core Workflow**
1. **Parse Access:** Read each trace instruction.  
2. **Address Calculation:** Extract **tag** and **set index** from the 64-bit address.  
3. **Set Selection:** Locate the correct cache set (2D array of structs).  
4. **Hit Check:** Match tags in valid lines.  
5. **Miss Handling:**  
   - If an empty line exists → fill it.  
   - If all lines are occupied → **evict** using LRU.  


### **Part 2: LRU Policy Implementation**

The existing simulator (`cachesim.cpp`) was modified to integrate the **LRU policy**.

#### **Before (Naive Policy)**
- The cache always evicted **Way 0**, regardless of usage.
- Inefficient, as frequently accessed blocks could be evicted prematurely.

#### **After (LRU Policy)**
- Each cache line tracks a **timestamp counter**.
- On every access:
  - The accessed line resets its counter to **0** (most recently used).
  - Others increment by **1** (aging).
- On eviction, the line with the **largest counter** (oldest) is replaced.

This effectively applies the **Principle of Temporal Locality**, optimizing cache efficiency.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/060b06e6-d3e0-461c-b040-3ec66af5b556" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/57aa3e23-a15b-47d2-a256-c7beba2357f0" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/ec95605b-e4ab-4dfc-8d0b-b814aec537a1" />

## Module Structure

| Path | Description |
|------|--------------|
| **Policy_Exploration/** | Contains files for the LRU policy implementation. |
| ├── `cachesim.cpp` | C++ simulator source (LRU logic implemented in `cache_flush`). |
| ├── `cachesim.h` | Header file with LRU data structures and declarations. |
| ├── `Makefile` | Build script for the simulator. |
| └── `benchmarks/` | Contains benchmark assembly files (`exa.s`, `sort.s`). |
| **Simulator_Design/** | Contains files for the cache simulator from scratch. |
| ├── `csim.c` | Main C source for the simulator. |
| ├── `cachelab.h` | Header with cache struct definitions and utilities. |
| ├── `Makefile` | Build script for the simulator. |
| └── `traces/` | Contains memory traces (`dave.trace`, `yi.trace`, etc.). |


## Simulation and Results

### **Testing**
- **`csim.c` (Lab 09):**  
  Validated against a **reference simulator** using provided trace files.
- **`cachesim.cpp` (Lab 08):**  
  Benchmarked using **`exa.s`** and **`sort.s`** under multiple cache configurations (1-way, 2-way, 4-way).
  
<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/68dc0c60-1c4f-4327-b676-3cb5ff6fae03" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/9b67af3f-b893-4d5c-a9ba-64268532eb9a" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/7a4d59d9-2f8a-4287-884e-5b14be42a621" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/36c7c0e2-0e68-4a79-8b7b-243282e315fa" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/093a4db4-d124-44f4-9659-d48ead7dbddb" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/fcb11e76-cfd7-45b6-a098-5d42602b7ece" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/0964d13d-358b-4c64-af1d-b83a3542e980" />

### **Findings**

- **Key Finding 1:** LRU drastically reduces miss rates, especially in workloads with high temporal locality (e.g., `sort.s`).  
- **Key Finding 2:** LRU performs best with **higher associativity (4-way)**, as it gains more flexibility in replacement decisions.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/dee0403a-1082-4a31-9150-fb3246037049" />

## Tools Used

- **Languages:** C, C++
- **Toolchain:** GCC, G++, Make
- **Profiler:** Valgrind (for trace generation)
- **Environment:** Linux / UNIX-based systems

# Future Improvements

- Implement More Policies: Add and compare LFU, Random, and Pseudo-LRU strategies.
- Simulate Write Policies: Include Write-Back vs. Write-Through and Write-Allocate vs. No-Write-Allocate mechanisms.
- Multi-Level Caches: Extend csim.c to simulate a multi-level (L1 + L2) cache hierarchy.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/a78744e4-01f7-4376-8f18-e587fe1e5f4c" />

# License

This project is licensed under the MIT License

# Summary

This project serves as a practical exploration of cache architecture in computer systems — from designing a simulator to evaluating real-world replacement policies. It bridges theory with implementation, showcasing how software simulation can be used to analyze and optimize hardware-level performance.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/1fad4ff3-9660-4afc-beab-0597789e3fb8" />

# Regards 
### **Awais Asghar**

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/2fe9c2c0-50fe-4c80-ac6f-aea4d799a68f" />
