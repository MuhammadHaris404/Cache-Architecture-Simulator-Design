# Cache Architecture: Simulator Design

![Project Status](https://img.shields.io/badge/status-Completed-brightgreen.svg)
![Platform](https://img.shields.io/badge/platform-Software%20Simulation-blue.svg)
![Tool](https://img.shields.io/badge/tool-GCC%20%2F%20G%2B%2B-yellow.svg)
![Language](https://img.shields.io/badge/language-C%20%2F%20C%2B%2B-purple.svg)
![License: MIT](https://img.shields.io/badge/license-MIT-lightgrey.svg)

This repository contains **two key projects** that explore the core principles of cache architecture, both implemented in **C/C++**:

- **Cache Simulator:** A fully functional cache simulator built from scratch in C that models cache behavior using valgrind memory traces.
- **Replacement Policy Analysis:** Implementation and analysis of the **Least Recently Used (LRU)** replacement policy in a C++ cache simulator.

Together, this project demonstrate how cache mapping, operation, and replacement policies affect performance optimization.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/00993684-6935-4b5c-8112-c5c082aa1c73" />

## Project Overview

The **"Memory Wall"** problem highlights how CPU speeds have far outpaced main memory speeds. **Caches** bridge this gap by storing frequently used data in small, fast memory blocks. This project explores two core design questions:

1. **How do we design a cache?**  
   By building a flexible simulator (`csim.c`) that can model different cache configurations (Set size, Associativity, Block size) and measure performance.

2. **How do we optimize a cache?**  
   By implementing an intelligent **LRU** policy to replace naive eviction strategies, proving its effectiveness through simulation results.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/eafbce50-969c-4fe4-bcc4-349c928771a0" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/1d97da6e-7f72-4790-a41c-04aa4ffeb4cd" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/8abf47ee-0a74-4103-9680-7327d3d93755" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/6afe1b23-bf9e-495f-9121-cecac5711ee1" />

## Core Features

### **1. Configurable Cache Simulator**
- Developed in **C** from scratch.
- Parses **valgrind**-generated memory traces.
- Supports any `(S, E, B)` configuration (Sets, Associativity, Block size).
- Reports **hit**, **miss**, and **eviction** statistics.
- Enables detailed analysis of cache performance.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/a11e0cac-d811-4201-84a2-a11ac34a5404" />

### **2. LRU Replacement Policy**
- Implemented in **C++** within an existing cache simulator.
- Replaces a naive ‚Äúalways evict Way 0‚Äù policy.
- Uses **timestamp/counter-based tracking** to evict the **Least Recently Used** block.
- Demonstrates significantly reduced miss rates, especially for workloads with **temporal locality**.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/d644f140-b6be-432e-baea-e566ed0ab72e" />

## Architecture and Design

### **Part 1: Cache Simulator from Scratch**

The simulator (`csim.c`) models real cache hardware behavior and processes **memory traces** generated by valgrind. Each line of the trace represents a memory operation (e.g., `L 0x1a2b3c, 4`).

#### **Core Workflow**
1. **Parse Access:** Read each trace instruction.  
2. **Address Calculation:** Extract **tag** and **set index** from the 64-bit address.  
3. **Set Selection:** Locate the correct cache set (2D array of structs).  
4. **Hit Check:** Match tags in valid lines.  
5. **Miss Handling:**  
   - If an empty line exists ‚Üí fill it.  
   - If all lines are occupied ‚Üí **evict** using LRU.  

> **[IMAGE PLACEHOLDER]**: Insert a diagram showing cache address mapping (Tag, Set, Offset).

---

### **Part 2: LRU Policy Implementation**

The existing simulator (`cachesim.cpp`) was modified to integrate the **LRU policy**.

#### **Before (Naive Policy)**
- The cache always evicted **Way 0**, regardless of usage.
- Inefficient, as frequently accessed blocks could be evicted prematurely.

#### **After (LRU Policy)**
- Each cache line tracks a **timestamp counter**.
- On every access:
  - The accessed line resets its counter to **0** (most recently used).
  - Others increment by **1** (aging).
- On eviction, the line with the **largest counter** (oldest) is replaced.

This effectively applies the **Principle of Temporal Locality**, optimizing cache efficiency.

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/060b06e6-d3e0-461c-b040-3ec66af5b556" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/57aa3e23-a15b-47d2-a256-c7beba2357f0" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/ec95605b-e4ab-4dfc-8d0b-b814aec537a1" />

<img width="1920" height="1080" alt="Image" src="https://github.com/user-attachments/assets/9b67af3f-b893-4d5c-a9ba-64268532eb9a" />

## Module Structure

| Path | Description |
|------|--------------|
| **Lab08_Policy_Exploration/** | Contains files for the LRU policy implementation. |
| ‚îú‚îÄ‚îÄ `cachesim.cpp` | C++ simulator source (LRU logic implemented in `cache_flush`). |
| ‚îú‚îÄ‚îÄ `cachesim.h` | Header file with LRU data structures and declarations. |
| ‚îú‚îÄ‚îÄ `Makefile` | Build script for the simulator. |
| ‚îî‚îÄ‚îÄ `benchmarks/` | Contains benchmark assembly files (`exa.s`, `sort.s`). |
| **Lab09_Simulator_Design/** | Contains files for the cache simulator from scratch. |
| ‚îú‚îÄ‚îÄ `csim.c` | Main C source for the simulator. |
| ‚îú‚îÄ‚îÄ `cachelab.h` | Header with cache struct definitions and utilities. |
| ‚îú‚îÄ‚îÄ `Makefile` | Build script for the simulator. |
| ‚îî‚îÄ‚îÄ `traces/` | Contains memory traces (`dave.trace`, `yi.trace`, etc.). |

---

## üìä Simulation and Results

### **Testing**
- **`csim.c` (Lab 09):**  
  Validated against a **reference simulator** using provided trace files.
- **`cachesim.cpp` (Lab 08):**  
  Benchmarked using **`exa.s`** and **`sort.s`** under multiple cache configurations (1-way, 2-way, 4-way).

### **Findings**

> **[IMAGE PLACEHOLDER]**: Insert a results bar chart comparing Random vs. LRU miss rates (from Slide 11).

- **Key Finding 1:** LRU drastically reduces miss rates, especially in workloads with high temporal locality (e.g., `sort.s`).  
- **Key Finding 2:** LRU performs best with **higher associativity (4-way)**, as it gains more flexibility in replacement decisions.

---

## üß∞ Tools Used

- **Languages:** C, C++
- **Toolchain:** GCC, G++, Make
- **Profiler:** Valgrind (for trace generation)
- **Environment:** Linux / UNIX-based systems

---

# Future Improvements

Implement More Policies: Add and compare LFU, Random, and Pseudo-LRU strategies.

Simulate Write Policies: Include Write-Back vs. Write-Through and Write-Allocate vs. No-Write-Allocate mechanisms.

Multi-Level Caches: Extend csim.c to simulate a multi-level (L1 + L2) cache hierarchy.

# üìú License

This project is licensed under the MIT License
.

# üßæ Summary

This project serves as a practical exploration of cache architecture in computer systems ‚Äî from designing a simulator to evaluating real-world replacement policies.
It bridges theory with implementation, showcasing how software simulation can be used to analyze and optimize hardware-level performance.
make
./csim -s <s> -E <E> -b <b> -t <tracefile>
